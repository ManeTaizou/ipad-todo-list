<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>ToDoリスト</title>
  <style>
    :root{
      --bg:#f4f5f7; --card:#fff; --ink:#172b4d; --muted:#6b778c;
      --border:#dfe1e6; --checked:#9ca3af; --radius:8px;
      --gap:6px; --pad-card:10px; --input-h:26px; --head-h:24px;
      --head-gap:6px; --row-gap:6px; --list-gap:2px; --header-h:40px;
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--ink);
      font-family:-apple-system,BlinkMacSystemFont,"Helvetica Neue","Hiragino Sans",sans-serif;
      font-size:14px; line-height:1.2; -webkit-text-size-adjust:100%;
    }
    header{
      background:var(--card); border-bottom:1px solid var(--border);
      position:sticky; top:0; z-index:10;
      display:flex; justify-content:space-between; align-items:center;
      padding:6px 10px; height:var(--header-h);
    }
    h1{font-size:16px;font-weight:600}
    .controls{display:flex; gap:4px; align-items:center}
    .controls button,.controls label{
      border:1px solid var(--border); background:var(--card); color:var(--ink);
      padding:2px 8px; border-radius:6px; font-size:12px; cursor:pointer; height:26px;
    }

    /* dvh優先（SafariのUIバー変動を回避） */
    .canvas{
      height:calc(100vh - var(--header-h));   /* fallback */
      height:calc(100dvh - var(--header-h));  /* modern iPadOS/Safari */
      padding:6px 6px calc(6px + env(safe-area-inset-bottom)) 6px;
      display:grid; grid-template-rows:1fr 1fr; gap:var(--row-gap);
      -webkit-overflow-scrolling:touch;
    }

    .top{ display:grid; grid-template-columns:1fr 1fr; gap:var(--gap); min-height:0; }
    .weekgrid{ display:grid; grid-template-columns:repeat(7,1fr); gap:var(--gap); min-height:0; }

    .card{
      background:var(--card); border:1px solid var(--border); border-radius:var(--radius);
      padding:var(--pad-card); display:flex; flex-direction:column; min-height:0; overflow:hidden;
    }
    .card h2,.card h3{
      color:var(--muted); font-weight:600; line-height:1;
      margin:0 0 var(--head-gap) 0; height:var(--head-h); display:flex; align-items:center;
    }
    .card h2{font-size:13px}
    .card h3{font-size:12px}

    /* 上段カード内 2列レイアウト */
    .cols{
      flex:1 1 auto; min-height:0;
      display:grid; grid-template-columns:1fr 1fr; gap:var(--gap);
    }
    .col{ display:flex; flex-direction:column; min-height:0; }
    .col .colhead{ margin:0 0 var(--head-gap) 0; height:var(--head-h); display:flex; align-items:center; }

    .list{
      flex:1 1 auto; min-height:0; display:flex; flex-direction:column; gap:var(--list-gap); overflow:auto;
    }
    .item{ display:flex; align-items:center; gap:6px; height:var(--input-h); flex:0 0 auto; }
    .item input[type="checkbox"]{ width:16px; height:16px; margin:0; flex:0 0 auto; }
    .item input.text{
      width:100%; border:none; border-bottom:1px solid var(--border);
      background:transparent; padding:2px 2px; font-size:14px; font-family:inherit; height:100%;
    }
    .item.checked input.text{ text-decoration:line-through; color:var(--checked); }

    /* “最終手段”としてだけ使う：下段の最終行の下線を消して数px稼ぐ */
    .micro-tweak .list .item:last-child input.text{ border-bottom:none; }

    @media (orientation:landscape) and (min-width:1024px){
      :root{ --gap:6px; --pad-card:10px; --input-h:26px; --head-h:24px; --head-gap:6px; --list-gap:2px; }
      body{ font-size:14px }
    }
  </style>
</head>
<body>
  <header>
    <h1>ToDoリスト</h1>
    <div class="controls">
      <button id="clearChecks">全チェック解除</button>
      <button id="resetAll">すべてリセット</button>
      <button id="exportData">バックアップ</button>
      <label for="importDataInput">読み込み</label>
      <input id="importDataInput" type="file" accept="application/json" style="display:none">
    </div>
  </header>

  <div class="canvas" id="canvasRoot">
    <!-- 上段：左＝今月(10×2) ／ 右＝来週・今週(10×2 各列に見出し) -->
    <div class="top" id="topRow">
      <!-- 今月：共通見出し＋2列 -->
      <div class="card" id="month">
        <h2>今月やること</h2>
        <div class="cols">
          <div class="col">
            <div class="list" data-section="month1"></div>
          </div>
          <div class="col">
            <div class="list" data-section="month2"></div>
          </div>
        </div>
      </div>

      <!-- 週：列ごとに見出し（左=来週／右=今週） -->
      <div class="card" id="week">
        <div class="cols">
          <div class="col">
            <h3 class="colhead">来週やること</h3>
            <div class="list" data-section="weekNext"></div>
          </div>
          <div class="col">
            <h3 class="colhead">今週やること</h3>
            <div class="list" data-section="weekThis"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- 下段：曜日 7カラム -->
    <div class="weekgrid" id="bottomRow">
      <div class="card"><h3>月曜日</h3><div class="list" data-section="月曜日"></div></div>
      <div class="card"><h3>火曜日</h3><div class="list" data-section="火曜日"></div></div>
      <div class="card"><h3>水曜日</h3><div class="list" data-section="水曜日"></div></div>
      <div class="card"><h3>木曜日</h3><div class="list" data-section="木曜日"></div></div>
      <div class="card"><h3>金曜日</h3><div class="list" data-section="金曜日"></div></div>
      <div class="card"><h3>土曜日</h3><div class="list" data-section="土曜日"></div></div>
      <div class="card"><h3>日曜日</h3><div class="list" data-section="日曜日"></div></div>
    </div>
  </div>

  <script>
    const STORAGE_KEY='ipad-todo';
    const days=["月曜日","火曜日","水曜日","木曜日","金曜日","土曜日","日曜日"];

    // 新構成：month1/month2、weekThis/weekNext、各曜日=10行
    const initial={
      month1:Array.from({length:10},()=>({checked:false,text:""})),
      month2:Array.from({length:10},()=>({checked:false,text:""})),
      weekThis:Array.from({length:10},()=>({checked:false,text:""})),
      weekNext:Array.from({length:10},()=>({checked:false,text:""})),
    };
    days.forEach(d=>initial[d]=Array.from({length:10},()=>({checked:false,text:""})));

    function normalizeToTen(arr){
      const c=Array.isArray(arr)?arr.slice(0,10):[];
      while(c.length<10) c.push({checked:false,text:""});
      return c;
    }

    // 旧データ移行：month→month1、week→weekThis
    function migrate(saved){
      const out={};
      out.month1 = saved.month1 ? normalizeToTen(saved.month1)
                : saved.month  ? normalizeToTen(saved.month) : normalizeToTen([]);
      out.month2 = saved.month2 ? normalizeToTen(saved.month2) : normalizeToTen([]);
      out.weekThis = saved.weekThis ? normalizeToTen(saved.weekThis)
                 : saved.week    ? normalizeToTen(saved.week) : normalizeToTen([]);
      out.weekNext = saved.weekNext ? normalizeToTen(saved.weekNext) : normalizeToTen([]);
      days.forEach(d=>{ out[d] = saved[d] ? normalizeToTen(saved[d]) : normalizeToTen([]); });
      return out;
    }

    let state;
    try{
      const saved=JSON.parse(localStorage.getItem(STORAGE_KEY)||"null");
      state=saved?migrate(saved):JSON.parse(JSON.stringify(initial));
    }catch{ state=JSON.parse(JSON.stringify(initial)); }

    function save(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }

    function createItem(section,i){
      const it=state[section][i];
      const div=document.createElement('div');
      div.className='item'+(it.checked?' checked':'');
      const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=it.checked;
      const input=document.createElement('input'); input.type='text'; input.className='text'; input.value=it.text;
      cb.onchange=()=>{it.checked=cb.checked;div.classList.toggle('checked',cb.checked);save();};
      input.oninput=()=>{it.text=input.value;save();};
      div.append(cb,input);
      return div;
    }

    function render(){
      document.querySelectorAll('.list').forEach(list=>{
        const sec=list.dataset.section;
        list.innerHTML='';
        if(state[sec]) for(let i=0;i<10;i++) list.append(createItem(sec,i));
      });
      requestAnimationFrame(reflowRows);
    }

    // 代表列の必要高さを実測
    function neededCardHeight(card){
      const cs=getComputedStyle(card);
      const pad = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);
      const border = parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth);

      // カード直下の見出し（h2/h3）があれば加算
      let headH = 0;
      const directHead = Array.from(card.children).find(el => el.tagName==='H2' || el.tagName==='H3');
      if(directHead){
        const dhcs=getComputedStyle(directHead);
        headH = directHead.getBoundingClientRect().height + parseFloat(dhcs.marginBottom);
      }

      // 代表コラム（最初の .col）
      const col = card.querySelector('.col') || card;
      let colHeadH = 0;
      const colHead = col.querySelector('.colhead');
      if(colHead){
        const chcs=getComputedStyle(colHead);
        colHeadH = colHead.getBoundingClientRect().height + parseFloat(chcs.marginBottom);
      }

      // リスト（代表1本）
      const list = card.querySelector('.list');
      const lcs = getComputedStyle(list);
      const gap = parseFloat(lcs.rowGap)||parseFloat(lcs.gap)||0;
      const firstItem=list.querySelector('.item');
      const itemH = firstItem ? firstItem.getBoundingClientRect().height : 26;
      const listNeed = (itemH*10) + (gap*9);

      return Math.ceil(pad + border + headH + colHeadH + listNeed);
    }

    // 上段=必要分ピッタリ / 下段=残り全部。下段が足りない時だけ段階的に詰める
    function reflowRows(){
      const rootStyle=getComputedStyle(document.documentElement);
      const baseInputH=parseFloat(rootStyle.getPropertyValue('--input-h'))||26;
      const baseListGap=parseFloat(rootStyle.getPropertyValue('--list-gap'))||2;

      const canvas=document.getElementById('canvasRoot');
      const topRow=document.getElementById('topRow');
      const bottomRow=document.getElementById('bottomRow');

      // 下段の微調整を一旦リセット
      bottomRow.classList.remove('micro-tweak');
      bottomRow.style.removeProperty('--input-h');
      bottomRow.style.removeProperty('--list-gap');

      const canvasStyle=getComputedStyle(canvas);
      const padBlock = parseFloat(canvasStyle.paddingTop) + parseFloat(canvasStyle.paddingBottom);
      const rowGap = parseFloat(canvasStyle.rowGap) || 0;
      const available = canvas.clientHeight - padBlock - rowGap; // トラック領域の高さ

      // 必要高さの算出
      const topNeed = Math.max(...Array.from(topRow.querySelectorAll('.card'), neededCardHeight));
      const bottomNeed0 = neededCardHeight(bottomRow.querySelector('.card'));

      // まず素直に配分
      let topH = Math.ceil(topNeed);
      let bottomH = Math.max(0, available - topH);

      // 下段が足りなければ「行間 → 行高 → 下線カット」の順で最小限だけ詰める
      let bottomNeed = bottomNeed0;
      let deficit = bottomNeed - bottomH;

      // ① 行間を詰める（9箇所で均等、小数px対応）
      if (deficit > 0) {
        const reduceGap = Math.min(baseListGap, deficit/9);
        bottomRow.style.setProperty('--list-gap', `${Math.max(0, baseListGap - reduceGap)}px`);
        bottomNeed = neededCardHeight(bottomRow.querySelector('.card'));
        deficit = bottomNeed - bottomH;
      }

      // ② 1行高を微縮（最大2pxまで、10行で均等）
      if (deficit > 0) {
        const reducePerRow = Math.min(2.0, deficit/10);
        bottomRow.style.setProperty('--input-h', `${Math.max(22, baseInputH - reducePerRow)}px`);
        bottomNeed = neededCardHeight(bottomRow.querySelector('.card'));
        deficit = bottomNeed - bottomH;
      }

      // ③ それでも >1px 足りないときだけ、最終行の下線を外す（最終手段）
      if (deficit > 1.0) {
        bottomRow.classList.add('micro-tweak');
        bottomNeed = neededCardHeight(bottomRow.querySelector('.card'));
        deficit = bottomNeed - bottomH;
      }

      // 仕上げ：可能なら下段に余りをすべて渡し、はみ出すなら上段を最大2pxだけ譲る
      const finalBottom = Math.max(bottomH, bottomNeed);
      const total = topH + finalBottom;
      if (total <= available){
        canvas.style.gridTemplateRows = `${topH}px ${available - topH}px`;
      }else{
        const shave = Math.min(2, total - available);
        canvas.style.gridTemplateRows = `${topH - shave}px ${available - (topH - shave)}px`;
      }
    }

    // 操作系
    document.getElementById('clearChecks').onclick=()=>{
      Object.keys(state).forEach(k=>state[k].forEach(i=>i.checked=false));
      save(); render();
    };
    document.getElementById('resetAll').onclick=()=>{
      if(confirm('リセットしますか？')){
        state=JSON.parse(JSON.stringify(initial)); save(); render();
      }
    };
    document.getElementById('exportData').onclick=()=>{
      const b=new Blob([JSON.stringify(state)],{type:'application/json'});
      const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download='todo.json'; a.click();
    };
    document.getElementById('importDataInput').onchange=e=>{
      const f=e.target.files[0]; if(!f) return;
      const r=new FileReader();
      r.onload=()=>{
        try{
          const incoming=JSON.parse(r.result);
          state=migrate(incoming); save(); render();
        }catch{ alert('読み込みに失敗しました'); }
      };
      r.readAsText(f);
    };

    // 初期描画＋回転/サイズ/フォント読み込み後に再計測
    render();
    if (document.fonts && document.fonts.ready) { document.fonts.ready.then(()=>requestAnimationFrame(reflowRows)); }
    addEventListener('resize', ()=>requestAnimationFrame(reflowRows));
    addEventListener('orientationchange', ()=>requestAnimationFrame(reflowRows));
  </script>
</body>
</html>
